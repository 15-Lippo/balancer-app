(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@ethersproject/address'), require('isomorphic-fetch'), require('@ethersproject/bignumber'), require('@ethersproject/contracts')) :
    typeof define === 'function' && define.amd ? define(['exports', '@ethersproject/address', 'isomorphic-fetch', '@ethersproject/bignumber', '@ethersproject/contracts'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ens-avatar-resolver'] = {}, global.address, global.fetch, global.bignumber, global.contracts));
}(this, (function (exports, address, fetch, bignumber, contracts) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

    const arweaveRegex = new RegExp(/ar:\/\/(.*)/);
    const parseURI$2 = (uri) => {
        const result = arweaveRegex.exec(uri);
        if (result === null)
            throw Error('parsing URI failed');
        const [, transactionId] = result;
        return transactionId;
    };
    const test$3 = (uri) => arweaveRegex.exec(uri) !== null;
    const resolve$3 = async (provider, ensName, address, uri) => {
        const transactionId = parseURI$2(uri);
        const baseUrl = 'https://arweave.net';
        const response = await fetch__default['default'](`${baseUrl}/graphql`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json;charset=UTF-8',
            },
            body: JSON.stringify({
                query: `
      {
        transactions(ids: ["${transactionId}"]) {
          edges {
            node {
              id
              owner {
                address
              }
            }
          }
        }
      }
      `,
            }),
        });
        const { data } = await response.json();
        const tx = data.transactions.edges[0].node;
        const response2 = await fetch__default['default'](`${baseUrl}/graphql`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json;charset=UTF-8',
            },
            body: JSON.stringify({
                query: `
    {
      transactions(owners: ["${tx.owner.address}"], tags: { name: "Origin", values: ["${tx.id}"] }, sort: HEIGHT_DESC) {
        edges {
          node {
            id
          }
        }
      }
    }
    `,
            }),
        });
        const { data: data2 } = await response2.json();
        if (data2 && data2.transactions.edges.length > 0) {
            return `${baseUrl}/${data2.transactions.edges[0].node.id}`;
        }
        else {
            return `${baseUrl}/${transactionId}`;
        }
    };
    const arweaveResolver = {
        test: test$3,
        resolve: resolve$3,
    };

    const getGatewayUrl = (uri, tokenId) => {
        const match = new RegExp(/([a-z]+)(?::\/\/|\/)(.*)/).exec(uri);
        if (!match || match.length < 3) {
            return uri;
        }
        const id = match[2];
        let url = uri;
        switch (match[1]) {
            case 'ar': {
                url = `https://arweave.net/${id}`;
                break;
            }
            case 'ipfs':
                if (id.includes('ipfs') || id.includes('ipns')) {
                    url = `https://gateway.ipfs.io/${id}`;
                }
                else {
                    url = `https://gateway.ipfs.io/ipfs/${id}`;
                }
                break;
            case 'ipns':
                if (id.includes('ipfs') || id.includes('ipns')) {
                    url = `https://gateway.ipfs.io/${id}`;
                }
                else {
                    url = `https://gateway.ipfs.io/ipns/${id}`;
                }
                break;
        }
        return tokenId ? url.replace(/{id}/g, tokenId) : url;
    };

    const erc1155Regex = new RegExp(/eip155:1\/erc1155:(\w+)\/(\w+)/);
    const erc1155Abi = [
        'function balanceOf(address _owner, uint256 _id) view returns (uint256)',
        'function uri(uint256 _id) view returns (string)',
    ];
    const parseURI$1 = (uri) => {
        const result = erc1155Regex.exec(uri);
        if (result === null)
            throw Error('parsing URI failed');
        const [, contractAddress, tokenId] = result;
        return [contractAddress, bignumber.BigNumber.from(tokenId)];
    };
    const test$2 = (uri) => erc1155Regex.exec(uri) !== null;
    const resolve$2 = async (provider, ensName, address, uri) => {
        const [contractAddress, tokenId] = parseURI$1(uri);
        const erc1155Contract = new contracts.Contract(contractAddress, erc1155Abi, provider);
        const userBalance = await erc1155Contract.balanceOf(address, tokenId);
        if (userBalance.isZero())
            return null;
        const tokenURI = await erc1155Contract.uri(tokenId);
        const response = await fetch__default['default'](getGatewayUrl(tokenURI, tokenId.toHexString().slice(2)));
        return (await response.json()).image;
    };
    const erc1155Resolver = {
        test: test$2,
        resolve: resolve$2,
    };

    const erc721Regex = new RegExp(/eip155:1\/erc721:(\w+)\/(\w+)/);
    const erc721Abi = [
        'function ownerOf(uint256 tokenId) view returns (address)',
        'function tokenURI(uint256 _tokenId) external view returns (string)',
    ];
    const parseURI = (uri) => {
        const result = erc721Regex.exec(uri);
        if (result === null)
            throw Error('parsing URI failed');
        const [, contractAddress, tokenId] = result;
        return [contractAddress, bignumber.BigNumber.from(tokenId)];
    };
    const test$1 = (uri) => erc721Regex.exec(uri) !== null;
    const resolve$1 = async (provider, ensName, address, uri) => {
        const [contractAddress, tokenId] = parseURI(uri);
        const erc721Contract = new contracts.Contract(contractAddress, erc721Abi, provider);
        const tokenOwner = await erc721Contract.ownerOf(tokenId);
        if (tokenOwner.toLowerCase() !== address.toLowerCase())
            return null;
        const tokenURI = await erc721Contract.tokenURI(tokenId);
        const response = await fetch__default['default'](getGatewayUrl(tokenURI, tokenId.toHexString()));
        return (await response.json()).image;
    };
    const erc721Resolver = {
        test: test$1,
        resolve: resolve$1,
    };

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const test = (uri) => true;
    const resolve = async (provider, ensName, address, uri) => getGatewayUrl(uri);
    const fallbackResolver = {
        test,
        resolve,
    };

    const avatarResolvers = [erc721Resolver, erc1155Resolver, arweaveResolver];

    const _resolveAvatar = async (provider, ensName, address) => {
        const resolver = await provider.getResolver(ensName);
        if (resolver === null)
            return null;
        const uri = await resolver.getText('avatar');
        if (uri === null)
            return null;
        const avatarResolver = avatarResolvers.find((resolver) => resolver.test(uri));
        try {
            if (avatarResolver !== undefined) {
                return await avatarResolver.resolve(provider, ensName, address, uri);
            }
            return await fallbackResolver.resolve(provider, ensName, address, uri);
        }
        catch {
            return null;
        }
    };
    /**
     * @notice Resolves the avatar attached to a given ENS name
     * @param provider A provider with ENS resolution capabilities
     * @param addressOrEns The ENS name (or address) to resolve the avatar of.
     * @returns a URL to the provided ENS name's avatar or null if no avatar exists
     */
    const resolveENSAvatar = async (provider, addressOrEns) => {
        if (address.isAddress(addressOrEns)) {
            const ensName = await provider.lookupAddress(addressOrEns);
            if (ensName !== null) {
                return _resolveAvatar(provider, ensName, addressOrEns);
            }
            else {
                return null;
            }
        }
        else {
            const address = await provider.resolveName(addressOrEns);
            if (address !== null) {
                return _resolveAvatar(provider, addressOrEns, address);
            }
            else {
                return null;
            }
        }
    };

    exports._resolveAvatar = _resolveAvatar;
    exports.resolveENSAvatar = resolveENSAvatar;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
